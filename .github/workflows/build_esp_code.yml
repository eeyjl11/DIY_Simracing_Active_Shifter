name: ESP-IDF Build

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  lint:
    name: Lint (clang-tidy via ESP-IDF)
    runs-on: ubuntu-latest
    env:
      IDF_VERSION: v5.5
      IDF_DIR: ${{ github.workspace }}/.esp/idf/v5.5/esp-idf
      IDF_TOOLS_PATH: ${{ github.workspace }}/.esp/tools
      ESP_IDF_EXPORT_DEBUG: "1"   # extra logs if export.sh fails
    steps:
      - uses: actions/checkout@v4

      # Reuse IDF + tools across runs
      - name: Cache ESP-IDF & tools
        id: idf-cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.espressif
            ${{ env.IDF_TOOLS_PATH }}
            ${{ github.workspace }}/.esp/idf
          key: ${{ runner.os }}-espidf-${{ env.IDF_VERSION }}

      - name: Bootstrap ESP-IDF (first run only)
        if: steps.idf-cache.outputs.cache-hit != 'true'
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "$(dirname "${IDF_DIR}")"
      
          if [ -d "${IDF_DIR}/.git" ]; then
            echo "Reusing existing esp-idf repo at ${IDF_DIR}"
            git -C "${IDF_DIR}" remote set-url origin https://github.com/espressif/esp-idf
            git -C "${IDF_DIR}" fetch --tags --depth 1 origin "${IDF_VERSION}"
            # Try tag ref explicitly first, then plain tag
            git -C "${IDF_DIR}" checkout -f "refs/tags/${IDF_VERSION}" 2>/dev/null || \
            git -C "${IDF_DIR}" checkout -f "${IDF_VERSION}"
          else
            echo "Fresh clone of esp-idf ${IDF_VERSION} into ${IDF_DIR}"
            rm -rf "${IDF_DIR}" || true
            git clone --depth 1 --branch "${IDF_VERSION}" https://github.com/espressif/esp-idf "${IDF_DIR}"
          fi
      
          # Install required tools (idempotent)
          python3 "${IDF_DIR}/tools/idf_tools.py" install
          # Linter job only: install esp-clang as well
          if [ "${{ job.status }}" != "" ]; then :; fi

      - name: Install esp-clang (first run only)
        if: steps.idf-cache.outputs.cache-hit != 'true'
        shell: bash
        run: |
          set -euo pipefail
          python3 "${IDF_DIR}/tools/idf_tools.py" install esp-clang

      # On all runs: set IDF_PATH and verify
      - name: Set IDF_PATH & verify
        shell: bash
        run: |
          set -euo pipefail
          echo "IDF_PATH=${IDF_DIR}" >> "$GITHUB_ENV"
          . "${IDF_DIR}/export.sh"
          idf.py --version

      - name: Run clang-tidy (project files only)
        shell: bash
        env:
          IDF_TOOLCHAIN: clang
        # Non-blocking on pushes, blocking on PRs
        continue-on-error: ${{ github.event_name == 'push' }}
        run: |
          set -euo pipefail
          . "${IDF_DIR}/export.sh"
          idf.py set-target esp32s3
          # Analyze only your sources; exclude esp-idf and the .esp cache
          idf.py clang-check \
            --source-filter '(^|/)(main|components)/' \
            --exclude-paths '(/\.esp/|/esp-idf/)' \
            --run-clang-tidy-options='-quiet'
          # Optional: HTML report
          python -m pip install codereport || true
          idf.py clang-html-report || true

      - name: Upload lint artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: esp-idf-clang-tidy-report
          path: |
            warnings.txt
            html_report/

  build:
    name: Build (gated by lint on PRs)
    runs-on: ubuntu-latest
    needs: lint
    env:
      IDF_VERSION: v5.5
      IDF_DIR: ${{ github.workspace }}/.esp/idf/v5.5/esp-idf
      IDF_TOOLS_PATH: ${{ github.workspace }}/.esp/tools
      ESP_IDF_EXPORT_DEBUG: "1"
    steps:
      - uses: actions/checkout@v4

      - name: Restore ESP-IDF & tools cache
        id: idf-cache
        uses: actions/cache@v4
        with:
          path: |
            ~/.espressif
            ${{ env.IDF_TOOLS_PATH }}
            ${{ github.workspace }}/.esp/idf
          key: ${{ runner.os }}-espidf-${{ env.IDF_VERSION }}

      # Only clone/install if cache is cold
      - name: Bootstrap ESP-IDF (first run only)
        if: steps.idf-cache.outputs.cache-hit != 'true'
        shell: bash
        run: |
          set -euo pipefail
          mkdir -p "$(dirname "${IDF_DIR}")"
      
          if [ -d "${IDF_DIR}/.git" ]; then
            echo "Reusing existing esp-idf repo at ${IDF_DIR}"
            git -C "${IDF_DIR}" remote set-url origin https://github.com/espressif/esp-idf
            git -C "${IDF_DIR}" fetch --tags --depth 1 origin "${IDF_VERSION}"
            # Try tag ref explicitly first, then plain tag
            git -C "${IDF_DIR}" checkout -f "refs/tags/${IDF_VERSION}" 2>/dev/null || \
            git -C "${IDF_DIR}" checkout -f "${IDF_VERSION}"
          else
            echo "Fresh clone of esp-idf ${IDF_VERSION} into ${IDF_DIR}"
            rm -rf "${IDF_DIR}" || true
            git clone --depth 1 --branch "${IDF_VERSION}" https://github.com/espressif/esp-idf "${IDF_DIR}"
          fi
      
          # Install required tools (idempotent)
          python3 "${IDF_DIR}/tools/idf_tools.py" install
          # Linter job only: install esp-clang as well
          if [ "${{ job.status }}" != "" ]; then :; fi

      - name: Set IDF_PATH & verify
        shell: bash
        run: |
          set -euo pipefail
          echo "IDF_PATH=${IDF_DIR}" >> "$GITHUB_ENV"
          . "${IDF_DIR}/export.sh"
          idf.py --version

      - name: Build
        shell: bash
        # Non-blocking on pushes, blocking on PRs
        continue-on-error: ${{ github.event_name == 'push' }}
        run: |
          set -euo pipefail
          . "${IDF_DIR}/export.sh"
          idf.py set-target esp32s3
          idf.py build

      # Emit size reports for the memcheck job
      - name: Generate size reports
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          . "${IDF_DIR}/export.sh"
          idf.py size --format text --output-file build/size.txt
          idf.py size-components --format csv --output-file build/size-components.csv

      - name: Upload size artifacts
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: idf-size
          path: |
            build/size.txt
            build/size-components.csv
            build/*.map

  memcheck:
    name: Memory Size Check
    runs-on: ubuntu-latest
    needs: build
    # Non-blocking on pushes, blocking on PRs (add this check to branch rules if you want it required)
    continue-on-error: ${{ github.event_name == 'push' }}
    env:
      # Optional thresholds (bytes). Leave blank to only report.
      MAX_IRAM: ""          # e.g. 131072
      MAX_DRAM: ""          # e.g. 180736
      MAX_FLASH_CODE: ""    # bytes
      MAX_FLASH_DATA: ""    # bytes
      MAX_IMAGE_SIZE: ""    # bytes
    steps:
      - uses: actions/checkout@v4

      - name: Download size artifacts
        uses: actions/download-artifact@v4
        with:
          name: idf-size
          path: build

      - name: Verify memory sizes against thresholds
        shell: bash
        run: |
          set -euo pipefail
          python3 - << 'PY'
          import os, re, sys, pathlib
          p = pathlib.Path('build/size.txt')
          if not p.exists():
              print("ERROR: build/size.txt not found. Did the build job run?")
              sys.exit(2)
          text = p.read_text(encoding='utf-8', errors='ignore').splitlines()

          def first_number(line):
              import re
              nums = re.findall(r'(\d+)', line)
              return int(nums[0]) if nums else None

          values = {}
          def grab(label):
              for l in text:
                  if label in l and '.text' not in l and '.rodata' not in l and '.vectors' not in l and '.appdesc' not in l:
                      n = first_number(l)
                      if n is not None:
                          values[label] = n
                          return
          for k in ['IRAM','DRAM','Flash Code','Flash Data']:
              grab(k)
          for l in text:
              if 'Total image size' in l:
                  n = first_number(l)
                  if n is not None:
                      values['Total image size'] = n
                  break

          thresholds = {
              'IRAM': os.getenv('MAX_IRAM') or None,
              'DRAM': os.getenv('MAX_DRAM') or None,
              'Flash Code': os.getenv('MAX_FLASH_CODE') or None,
              'Flash Data': os.getenv('MAX_FLASH_DATA') or None,
              'Total image size': os.getenv('MAX_IMAGE_SIZE') or None,
          }

          failures = []
          lines = []
          for k,v in values.items():
              lim = thresholds.get(k)
              line = f"{k}: {v} bytes"
              if lim:
                  try:
                      lim_i = int(lim)
                      line += f" (limit {lim_i})"
                      if v > lim_i:
                          failures.append(f"{k} {v}>{lim_i}")
                  except ValueError:
                      line += f" (invalid limit '{lim}')"
              lines.append(line)

          pathlib.Path('memcheck-summary.txt').write_text("\n".join(lines) + ("\nFAILED: " + ", ".join(failures) if failures else "") + "\n", encoding='utf-8')
          print("\n".join(lines))
          if failures:
              print("ERROR: Memory thresholds exceeded:", ", ".join(failures))
              sys.exit(1)
          PY

      - name: Upload memcheck summary
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: memcheck-summary
          path: memcheck-summary.txt
